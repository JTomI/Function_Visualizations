import numpy as np
from numpy import *
import matplotlib
import os
import matplotlib.pyplot as plt
from scipy import special as sp
from scipy.integrate import quad
from matplotlib import cm
from mpl_toolkits.mplot3d import Axes3D
from tqdm import tqdm
# from matplotlib.animation import FuncAnimation as animate

def cut(array, zlim=10.0, nanval=0):
	'''
	Handles NaNs and cuts z to ignore divergent parts of function.
	:Param array: The function to be tailored
	:Param zlim: Defines zmin and zmax constraint for function
	:Param nanval: Optional parameter, sets value to redefine NaNs as. 
	:Returns array: The array in it's original shape, now constrained between (-zlim < z < zlim) with NaNs redefined
	'''
	x,y = np.shape(array)
	array = array.flatten() #Flatten the original array so you can properly contruct/apply truth array where_are_NaNs
	where_are_NaNs = isnan(array)
	array[where_are_NaNs] = nanval # redefine NaN
	array[array>zlim] = zlim 
	array[array<-zlim] = -zlim
	return array.reshape(x,y)

def grid(lim=3, grid=1500):
	'''
	Sets up square mesh grid representing the xy plane.
	:Param lim: Sets up axes with |x| < lim and |y| < lim
	:Param grid: Side length of square array (grid x grid).
	Optimal values is grid = 1500x1500
	:Returns: Tuple of meshed (X,Y) matrices for given limits
	'''
	x,y = np.linspace(-lim,lim,grid), np.linspace(-lim,lim,grid)
	return np.meshgrid(x,y)

def gamma(xylim=5): # zlim = 5
	'''Calculates the gamma function in the complex xy-plane.'''
	X,Y = grid(lim=xylim)
	return np.abs(sp.gamma(X+1.0j*Y))

def beta(xylim=3): # zlim = 10
	'''Calculates the beta function for values in the real xy-plane.'''
	X,Y = grid(lim=xylim)
	return sp.beta(X,Y)

def frame(array,fname ='',index = 0,cmap='Spectral'):
	'''
	Saves a .png of the numpy array input, in any shape.
	:Param array: The numpy array to be converted to a .png.
	:Param fname: The name to be assigned to the .png file.
	:Param index: Index of the saved frames, so a given frame
	is not overwitten by later frames. Used for animation.
	:Param cmap: The colormap to be applied to the image. Must be 
	chosen from matplotlib's colormap libraries.
	:Returns: Image saved as cwd/frames/fname_index.png
	'''
	filename = os.getcwd()+'/frames/{}_{}.png'.format(fname, index)
	matplotlib.image.imsave(filename, array, cmap=cmap)

def gen_frames(function,zlims,fname ='',cmap='Spectral'):
	'''
	Generates a set of indexed frames in .png format to be used by ffmpeg to make an animation.
	:Param function: The function to be used for frame generation.
	:Param zlims: Sets the highest z value that the function will be cut to.
	:Param fname: The name to be assigned to each .png file.
	:Param cmap: The colormap to be applied to the image. Must be 
	chosen from matplotlib's colormap libraries.
	:Returns: Set of images located in cwd/frames/
	'''
	array = function()
	print('Generating Frames')
	for i in tqdm(range(zlims.size)):
		cutarray = cut(array,zlim=zlims[i])
		frame(cutarray,fname=fname,index=i,cmap=cmap)

def stitch(function, zlims, fname='fname', cmap='Spectral', off=0, fps=20):
	'''
	Uses the ffmpeg terminal command to stitch together indexed .png frames into a .mp4 movie.
	:Param function: The function to be animated.
	:Param zlims: Sets the highest z value that the function will be cut to. 
	:Param fname: The name of the .mp4 file to be created.
	:Param cmap: The colormap to be applied to all frames. Must be 
	chosen from matplotlib's colormap libraries.
	:Param off: Index offset. Currently redundant, leave as default.
	:Param fps: The framerate of the animation to be generated by ffmpeg
	:Returns: fname.mp4 located in cwd. 
	'''
	
	# Direct to frames to be iterated over. %d is interpreted by ffmpeg along with -start_number.
	# This %d allows ffmpeg to iterated over sequential files in the /frames folder, and make a movie
	gen_frames(function, zlims, fname=fname, cmap=cmap) # make frames at given fps
	input(' :: Check /frames to see generated frames :: \n :: Press <Enter> to Continue :: ')
	cwd = os.getcwd()
	location = cwd + '/frames/{}_%d.png'.format(fname) 
	# command output will be mp4 file at given fps. Suppress command line output (verbose command)
	ffmpeg_cmd = "ffmpeg -r {} -start_number {} -i {} -vcodec mpeg4 {}.mp4".format(fps , off , location , fname)
	os.system(ffmpeg_cmd) # make the animation
	os.system('rm -R frames') # Delete frames folder.
	os.system('mkdir frames') # Remake frames folder (crude cleanup).
	savemsg = ' :: {}.mp4 saved in {} :: '.format(fname, cwd)
	return(savemsg)

#-------------------------Miscellaneous Function definitions using gamma or beta with modded Input Grid--------------------------------------- 
def stripes(xylim=5):
	'''Calculates some interesting line contours of gamma function in the complex xy-plane.'''
	X,Y = grid(lim=xylim)
	return np.abs(sp.gamma(X-Y))

def waves(xylim=5):
	X,Y = grid(lim=xylim)
	return np.abs(sp.gamma(X-np.sin(Y)))

def tiles(xylim=5):
	X,Y = grid(lim=xylim)
	return np.abs(sp.gamma(np.cos(X)-np.sin(Y)))

def mask(xylim=5):
	X,Y = grid(lim=xylim)
	return np.abs(sp.gamma(np.cos(np.sinh(X))-np.sin(np.cosh(Y))))

def main():
	zlims = np.linspace(.01,10,200)
	msg = stitch(gamma,zlims,fname='test',fps=10)
	print(msg)

	# ---Misc 3D projection---
	# g = 50
	# X,Y = grid(grid = g)
	# function = test(g = g)
	# fig = plt.figure()
	# ax = fig.add_subplot(1,1,1,projection ='3d')
	# vis = ax.plot_trisurf(X.flatten(),Y.flatten(),function.flatten(),cmap=plt.cm.CMRmap)
	# fig.colorbar(vis, shrink=0.5, aspect=5)
	# fig.show()
	# input('__Enter__')


if __name__ =='__main__':
	main()

